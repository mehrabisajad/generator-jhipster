<%
const enumImports = this.generateEntityClientEnumImportsForApplication(fields, dasherizedBaseName);
%>
import { random } from "avanng/common/core";
import { BaseCommand, BaseCommandHandler, HandlerResponse, safeCommand } from "avanng/domain";
import { <%= entityAngularName %> } from "<%= dasherizedBaseName %>/domain/model/<%= entityFileName %>.model";
<%_ enumImports.forEach((importedPath, importedType) => { _%>
    import { <%- importedType %> } from '<%- importedPath %>';
<%_ }); _%>
<%_ for (const relationship of relationships) {
    const { propertyName, relationshipFieldName, relationshipRequired, otherEntity, collection, otherEntityField } = relationship;
        if (!relationship.otherEntity.readOnly) {
        const enumImports2 = this.generateEntityClientEnumImportsForApplication(relationship.otherEntity.fields, dasherizedBaseName);
_%>
<%_ enumImports2.forEach((importedPath, importedType) => { _%>
import { <%- importedType %> } from '<%- importedPath %>';
<%_ }); _%>
<%_ } } _%>
<%_ for (const relationshipsByType of Object.values(differentRelationships)) {
        for (const relationship of relationshipsByType) {
            if (relationship.collection && relationship.relationshipType !== 'many-to-many') { _%>
<%_             if (!relationship.otherEntity.readOnly) {
                    const enumImports2 = this.generateEntityClientEnumImportsForApplication(relationship.otherEntity.fields, dasherizedBaseName);
_%>
<%_ enumImports2.forEach((importedPath, importedType) => { _%>
    import { <%- importedType %> } from '<%- importedPath %>';
<%_ }); _%>
<%_ } } } } _%>

import { <%= entityAngularName %>PersistenceCommandPort} from "../../port/<%= entityFolderName %>/<%= entityFileName %>-persistence-command.port";

const __name__ = random();

export class <%= entityAngularName %>CreateOrUpdateCommand implements BaseCommand<void> {
  commandId = __name__;

<%_ for (const field of fields) {
    const { fieldName, fieldValidationRequired, id } = field;
    const tsType = `${field.fieldIsEnum ? 'keyof typeof ' : ''}${field.tsType}`;
_%>
<%= fieldName %>?: <%= tsType %> | null;
<%_ if (field.fieldTypeBinary && !field.blobContentTypeText) { _%>
    <%= fieldName %>ContentType<% if (!id /* && !fieldValidationRequired */) { %>?<% } %>: string<% if (!id /* && !fieldValidationRequired */) { %> | null<% } %>,
<%_ } _%>
<%_ } _%>
<%_ for (const relationship of relationships.filter(rel => rel.persistableRelationship || rel.relationshipEagerLoad)) {
        const { propertyName, relationshipRequired, otherEntity, collection, otherEntityField } = relationship;
_%>
<%_     if (!relationship.otherEntity.readOnly && relationship.relationshipType === 'many-to-many') { _%>
    <%= relationship.propertyName %>?: {
    <%_ for (const field2 of relationship.otherEntity.fields) {
        const { fieldName, id } = field2;
        const tsType = `${field2.fieldIsEnum ? 'keyof typeof ' : ''}${field2.tsType}`;
    _%>
    <%= fieldName %>?: <%= tsType %> | null;
    <%_ if (field2.fieldTypeBinary && !field2.blobContentTypeText) { _%>
        <%= fieldName %>ContentType<% if (!id /* && !fieldValidationRequired */) { %>?<% } %>: string<% if (!id /* && !fieldValidationRequired */) { %> | null<% } %>,
    <%_ } _%>
    <%_ } _%>
    <%_ for (const relationship2 of relationship.otherEntity.relationships.filter(rel => rel.persistableRelationship || rel.relationshipEagerLoad)) {
        const { propertyName, relationshipRequired, otherEntity, collection, otherEntityField } = relationship2;
    _%>
    <%_ } _%>
    }[] | null;
<%_ } _%>
    <%= relationship.relationshipFieldName %>Id<% if (collection) { %>s<% } %>?: <%= otherEntity.tsKeyType %><% if (collection) { %>[]<% } %> | null;
<%_ } _%>
<%_ for (const relationshipsByType of Object.values(differentRelationships)) {
        for (const relationship of relationshipsByType) {
if (relationship.collection && relationship.relationshipType !== 'many-to-many') { _%>
<%_ if (!relationship.otherEntity.readOnly) { _%>
<%= relationship.propertyName %>?: {
        <%_ for (const field2 of relationship.otherEntity.fields) {
            const { fieldName, id } = field2;
            const tsType = `${field2.fieldIsEnum ? 'keyof typeof ' : ''}${field2.tsType}`;
        _%>
        <%= fieldName %>?: <%= tsType %> | null;
        <%_ if (field2.fieldTypeBinary && !field2.blobContentTypeText) { _%>
            <%= fieldName %>ContentType<% if (!id /* && !fieldValidationRequired */) { %>?<% } %>: string<% if (!id /* && !fieldValidationRequired */) { %> | null<% } %>,
        <%_ } _%>
        <%_ } _%>
        <%_ for (const relationship2 of relationship.otherEntity.relationships.filter(rel => rel.persistableRelationship || rel.relationshipEagerLoad)) {
            const { propertyName, relationshipRequired, otherEntity, collection, otherEntityField } = relationship2;
        _%>
        <%= propertyName %>Id<% if (collection) { %>s<% } %>?: <%= otherEntity.tsKeyType %><% if (collection) { %>[]<% } %> | null;
        <%_ } _%>
        }[] | null;
<%_ } _%>
<%= relationship.relationshipFieldName %>Ids?: <%= relationship.otherEntity.tsKeyType %>[] | null;
<%_ } } } _%>

  constructor(command?: Partial<<%= entityAngularName %>CreateOrUpdateCommand> | null) {
    Object.assign(this, command);
  }

}

export class <%= entityAngularName %>CreateOrUpdateCommandHandler implements BaseCommandHandler<<%= entityAngularName %>CreateOrUpdateCommand, void> {
  commandId = __name__;

  constructor(private readonly <%= entityInstance %>PersistenceCommandPort: <%= entityAngularName %>PersistenceCommandPort) {}

  handle(command: <%= entityAngularName %>CreateOrUpdateCommand): HandlerResponse<void> {
    const <%= entityInstance %> = new <%= entityAngularName %>(safeCommand(command));

    if (<%= entityInstance %>.id) {
      <%= entityInstance %>.prepareForUpdate();

      return {
        result: this.<%= entityInstance %>PersistenceCommandPort.update(<%= entityInstance %>),
        domain: <%= entityInstance %>
      };
    }

    <%= entityInstance %>.prepareForCreation();
    return {
      result: this.<%= entityInstance %>PersistenceCommandPort.create(<%= entityInstance %>),
      domain: <%= entityInstance %>
    };
  }


}
