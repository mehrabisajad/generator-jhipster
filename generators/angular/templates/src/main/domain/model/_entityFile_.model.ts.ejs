<%
const enumImports = this.generateEntityClientEnumImports(fields);
const hasStatusField = this.hasStatusField(fields, this)
%>
import { BaseModel } from 'avanng/domain';
<%_ for (const relationshipsByType of Object.values(differentRelationships).filter(relationshipsByType => relationshipsByType.some(relationship => relationship.otherEntity.entityAngularName !== entityAngularName))) {
      const { otherEntity } = relationshipsByType[0];
_%>

import { I<%- otherEntity.entityAngularName %> } from './<%= otherEntity.entityFileName %>.model';
<%_ } _%>
<%_ enumImports.forEach((importedPath, importedType) => { _%>
import { <%- importedType %> } from '<%- importedPath %>';
<%_ }); _%>
import { <%= entityAngularName %>CreatedEvent, <%= entityAngularName %>DeletedEvent, <%= entityAngularName %>UpdatedEvent } from "../event/<%= entityFolderName %>";

export interface I<%= entityAngularName %> {
<%_ for (const field of fields) {
      const { fieldName, fieldValidationRequired, id } = field;
      const tsType = `${field.fieldIsEnum ? 'keyof typeof ' : ''}${field.tsType}`;
_%>
  <%= fieldName %>?: <%= tsType %> | null;
  <%_ if (field.fieldTypeBinary && !field.blobContentTypeText) { _%>
  <%= fieldName %>ContentType<% if (!id /* && !fieldValidationRequired */) { %>?<% } %>: string<% if (!id /* && !fieldValidationRequired */) { %> | null<% } %>,
  <%_ } _%>
<%_ } _%>
<%_ for (const relationship of relationships) {
      const { propertyName, relationshipFieldName, otherEntity, collection, otherEntityField } = relationship;
_%>
  <%= propertyName %>?: <% if (!otherEntity.embedded && (dtoMapstruct || otherEntity.builtInUser)) { %>Pick<<% } %>I<%= otherEntity.entityAngularName %><% if (!otherEntity.embedded && (dtoMapstruct || otherEntity.builtInUser)) { %>, '<%= otherEntity.primaryKey.name %>'<% if (otherEntity.primaryKey.name !== otherEntityField) { %> | '<%= otherEntityField %>'<% } %>><% } %><% if (collection) { %>[]<% } %> | null;
  <%= relationshipFieldName %>Id<% if (collection) { %>s<% } %>?: <%= otherEntity.tsKeyType %><% if (collection) { %>[]<% } %> | null;
<%_ } _%>
}

export class <%= entityAngularName %>  extends BaseModel implements I<%= entityAngularName %> {
<%_ for (const field of fields) {
      const { fieldName, fieldValidationRequired, id } = field;
      const tsType = `${field.fieldIsEnum ? 'keyof typeof ' : ''}${field.tsType}`;
_%>
  <%= fieldName %>?: <%= tsType %> | null;
  <%_ if (field.fieldTypeBinary && !field.blobContentTypeText) { _%>
  <%= fieldName %>ContentType<% if (!id /* && !fieldValidationRequired */) { %>?<% } %>: string<% if (!id /* && !fieldValidationRequired */) { %> | null<% } %>,
  <%_ } _%>
<%_ } _%>
<%_ for (const relationship of relationships) {
      const { propertyName, relationshipFieldName, otherEntity, collection, otherEntityField } = relationship;
_%>
  <%= propertyName %>?: <% if (!otherEntity.embedded && (dtoMapstruct || otherEntity.builtInUser)) { %>Pick<<% } %>I<%= otherEntity.entityAngularName %><% if (!otherEntity.embedded && (dtoMapstruct || otherEntity.builtInUser)) { %>, '<%= otherEntity.primaryKey.name %>'<% if (otherEntity.primaryKey.name !== otherEntityField) { %> | '<%= otherEntityField %>'<% } %>><% } %><% if (collection) { %>[]<% } %> | null;
  <%= relationshipFieldName %>Id<% if (collection) { %>s<% } %>?: <%= otherEntity.tsKeyType %><% if (collection) { %>[]<% } %> | null;
<%_ } _%>

    constructor(<%= entityInstance %>?: Partial<I<%= entityAngularName %>> | null) {
        super();
        Object.assign(this, <%= entityInstance %>);
    }

    static delete(id: <%= tsKeyType %>): <%= entityAngularName %> {
        const <%= entityInstance %> = new <%= entityAngularName %>({ id })
        <%= entityInstance %>.addDomainEvent(new <%= entityAngularName %>DeletedEvent({ id }));
        return <%= entityInstance %>;
    }

    checkValidation(): void {
<%_ for (const field of fields) {
    const { fieldName,  fieldValidationRequired, fieldValidationMinLength, fieldValidationMaxLength, fieldValidationMin, fieldValidationMax, fieldValidationPattern } = field;
    let listValidators = [];
    let andValidation = "this." + fieldName;
    if (fieldValidationRequired) {
        listValidators.push('!this.' + fieldName);
        andValidation = null;
    }
    if (fieldValidationMinLength) {
        listValidators.push('this.' + fieldName + ".length < " + field.fieldValidateRulesMinlength);
    }
    if (fieldValidationMaxLength) {
        listValidators.push('this.' + fieldName + ".length > " + field.fieldValidateRulesMaxlength);
    }
    if (fieldValidationMin) {
        listValidators.push('this.' + fieldName + " < " + field.fieldValidateRulesMin);
    }
    if (fieldValidationMax) {
        listValidators.push('this.' + fieldName + " > " + field.fieldValidateRulesMax);
    }
    if (fieldValidationPattern) {
        listValidators.push("!/" + field.fieldValidateRulesPattern + "/.test(this." + fieldName + ")");
    }
    if (listValidators.length) {
_%>
        if (<%- (andValidation ? andValidation + ' && (' : '') + listValidators.join(' || ') + (andValidation ? ')' : '')%> ) {
            throw new Error('<%= fieldName %> is invalid');
        }
<%_ }
} _%>
    }

    prepareForCreation(): void {
        if (this.id) {
            throw new Error('id is not null');
        }
        this.checkValidation();

        this.addDomainEvent(new <%= entityAngularName %>CreatedEvent({ ...this }));
    }

    prepareForUpdate(): void {
        if (!this.id) {
            throw Error('id is null');
        }
        this.checkValidation();

        this.addDomainEvent(new <%= entityAngularName %>UpdatedEvent({ ...this }));
    }

<%_ if (hasStatusField) { _%>
    setStatus(status: keyof typeof <%= hasStatusField.tsType %>): void {
        if (!this.id) {
            throw Error('id is null');
        }
        this.status = status;

        this.addDomainEvent(new <%= entityAngularName %>UpdatedEvent({ id: this.id, status: this.status }));
    }

<%_ } _%>
}
