<%
const enumImports = this.generateEntityClientEnumImports(fields);
const hasStatusField = this.hasStatusField(fields, this)
%>
import { BaseModel } from 'avanng/domain';

<%_ for (const relationshipsByType of Object.values(differentRelationships).filter(relationshipsByType => relationshipsByType.some(relationship => relationship.otherEntity.entityAngularName !== entityAngularName))) {
      const { otherEntity } = relationshipsByType[0];
      if (!otherEntity.readOnly) {
_%>
import { I<%- otherEntity.entityAngularName %> } from './<%= otherEntity.entityFileName %>.model';
<%_ }
} _%>
<%_ enumImports.forEach((importedPath, importedType) => { _%>
import { <%- importedType %> } from '<%- importedPath %>';
<%_ }); _%>
import { <%= entityAngularName %>CreatedEvent, <%= entityAngularName %>DeletedEvent, <%= entityAngularName %>UpdatedEvent } from "../event/<%= entityFolderName %>";

export interface I<%= entityAngularName %> {
<%_ for (const field of fields) {
      const { fieldName, fieldValidationRequired, id } = field;
      const tsType = `${field.fieldIsEnum ? 'keyof typeof ' : ''}${field.tsType}`;
_%>
  <%= fieldName %>?: <%= tsType %> | null;
  <%_ if (field.fieldTypeBinary && !field.blobContentTypeText) { _%>
  <%= fieldName %>ContentType<% if (!id /* && !fieldValidationRequired */) { %>?<% } %>: string<% if (!id /* && !fieldValidationRequired */) { %> | null<% } %>,
  <%_ } _%>
<%_ } _%>
<%_ for (const relationship of relationships) {
      const { propertyName, relationshipName, relationshipFieldName, otherEntity, collection, otherEntityField } = relationship;
_%>
  <%_ if (!otherEntity.readOnly) { _%>
  <%= propertyName %>?: <% if (!otherEntity.embedded && (dtoMapstruct || otherEntity.builtInUser)) { %>Pick<<% } %>I<%= otherEntity.entityAngularName %><% if (!otherEntity.embedded && (dtoMapstruct || otherEntity.builtInUser)) { %>, '<%= otherEntity.primaryKey.name %>'<% if (otherEntity.primaryKey.name !== otherEntityField) { %> | '<%= otherEntityField %>'<% } %>><% } %><% if (collection) { %>[]<% } %> | null;
  <%_ } _%>
  <%= relationshipFieldName %>Id<% if (collection) { %>s<% } %>?: <%= otherEntity.tsKeyType %><% if (collection) { %>[]<% } %> | null;
<%_ } _%>
<%_ for (const relationshipsByType of Object.values(differentRelationships)) {
    for (const relationship of relationshipsByType) {
      if (relationship.collection && relationship.relationshipType !== 'many-to-many') {
_%>
  <%_ if (!relationship.otherEntity.readOnly) { _%>
    <%= relationship.propertyName %>?: I<%= relationship.otherEntityAngularName %>[] | null;
  <%_ } _%>
    <%= relationship.relationshipFieldName %>Ids?: <%= relationship.otherEntity.tsKeyType %>[] | null;
<%_ } } } _%>

}

export class <%= entityAngularName %>  extends BaseModel implements I<%= entityAngularName %> {
<%_ for (const field of fields) {
      const { fieldName, fieldValidationRequired, id } = field;
      const tsType = `${field.fieldIsEnum ? 'keyof typeof ' : ''}${field.tsType}`;
_%>
  <%= fieldName %>?: <%= tsType %> | null;
  <%_ if (field.fieldTypeBinary && !field.blobContentTypeText) { _%>
  <%= fieldName %>ContentType<% if (!id /* && !fieldValidationRequired */) { %>?<% } %>: string<% if (!id /* && !fieldValidationRequired */) { %> | null<% } %>,
  <%_ } _%>
<%_ } _%>
<%_ for (const relationship of relationships) {
      const { propertyName, relationshipFieldName, otherEntity, collection, otherEntityField } = relationship;
_%>
    <%_ if (!otherEntity.readOnly) { _%>
  <%= propertyName %>?: <% if (!otherEntity.embedded && (dtoMapstruct || otherEntity.builtInUser)) { %>Pick<<% } %>I<%= otherEntity.entityAngularName %><% if (!otherEntity.embedded && (dtoMapstruct || otherEntity.builtInUser)) { %>, '<%= otherEntity.primaryKey.name %>'<% if (otherEntity.primaryKey.name !== otherEntityField) { %> | '<%= otherEntityField %>'<% } %>><% } %><% if (collection) { %>[]<% } %> | null;
    <%_ } _%>
  <%= relationshipFieldName %>Id<% if (collection) { %>s<% } %>?: <%= otherEntity.tsKeyType %><% if (collection) { %>[]<% } %> | null;
<%_ } _%>
<%_ for (const relationshipsByType of Object.values(differentRelationships)) {
        for (const relationship of relationshipsByType) {
if (relationship.collection && relationship.relationshipType !== 'many-to-many') {
_%>
<%_ if (!relationship.otherEntity.readOnly) { _%>
<%= relationship.propertyName %>?: I<%= relationship.otherEntityAngularName %>[] | null;
<%_ } _%>
<%= relationship.relationshipFieldName %>Ids?: <%= relationship.otherEntity.tsKeyType %>[] | null;
<%_ } } } _%>

    constructor(<%= entityInstance %>?: Partial<I<%= entityAngularName %>> | null) {
        super();
        Object.assign(this, <%= entityInstance %>);
    }

    static delete(id: <%= tsKeyType %>): <%= entityAngularName %> {
        const <%= entityInstance %> = new <%= entityAngularName %>({ id })
        <%= entityInstance %>.addDomainEvent(new <%= entityAngularName %>DeletedEvent({ id }));
        return <%= entityInstance %>;
    }

    checkValidation(): void {
<%_ for (const field of fields) {
    const { fieldName,  fieldValidationRequired, fieldValidationMinLength, fieldValidationMaxLength, fieldValidationMin, fieldValidationMax, fieldValidationPattern } = field;
    let listValidators = [];
    let andValidation = "this." + fieldName;
    if (fieldValidationRequired) {
        listValidators.push('!this.' + fieldName);
        andValidation = null;
    }
    if (fieldValidationMinLength) {
        listValidators.push('this.' + fieldName + ".length < " + field.fieldValidateRulesMinlength);
    }
    if (fieldValidationMaxLength) {
        listValidators.push('this.' + fieldName + ".length > " + field.fieldValidateRulesMaxlength);
    }
    if (fieldValidationMin) {
        listValidators.push('this.' + fieldName + " < " + field.fieldValidateRulesMin);
    }
    if (fieldValidationMax) {
        listValidators.push('this.' + fieldName + " > " + field.fieldValidateRulesMax);
    }
    if (fieldValidationPattern) {
        listValidators.push("!/" + field.fieldValidateRulesPattern + "/.test(this." + fieldName + ")");
    }
    if (listValidators.length) {
_%>
        if (<%- (andValidation ? andValidation + ' && (' : '') + listValidators.join(' || ') + (andValidation ? ')' : '')%> ) {
            throw new Error('<%= fieldName %> is invalid');
        }
<%_ }
} _%>
    <%_ for (const relationship of relationships) {
        const { propertyName, relationshipRequired, relationshipFieldName, otherEntity, collection, otherEntityField } = relationship;
        if (relationshipRequired) {
            let validationRequired = "!this." + relationshipFieldName + "Id" + (collection ? "s?.length" : "");
            let name = relationshipFieldName + 'Id' + (collection ? 's' : '');

            if (!relationship.otherEntity.readOnly) {
                validationRequired += ' && ' + "!this." + propertyName + (collection ? "?.length" : "");
                name += ' or ' + propertyName + ' are';
            } else {
                name += ' is';
            }
    _%>
    if (<%- validationRequired %>) {
        throw new Error('<%- name %> invalid');
    }
    <%_ } } _%>
    <%_ for (const relationshipsByType of Object.values(differentRelationships)) {
            for (const relationship of relationshipsByType) {
    if (relationship.relationshipRequired && relationship.collection && relationship.relationshipType !== 'many-to-many') {
        let validationRequired = "!this." + relationship.relationshipFieldName + "Ids?.length";
        let name = relationship.relationshipFieldName + 'Ids';
        if (!relationship.otherEntity.readOnly) {
            validationRequired += ' && ' + "!this." + relationship.propertyName + "?.length";
            name += ' or ' + relationship.propertyName + ' are';
        } else {
            name += ' is';
        }
    _%>
    if (<%- validationRequired %>) {
        throw new Error('<%- name %> invalid');
    }
    <%_ } } } _%>

    }

    prepareForCreation(): void {
        if (this.id) {
            throw new Error('id is not null');
        }
        this.checkValidation();

        this.addDomainEvent(new <%= entityAngularName %>CreatedEvent({ ...this }));
    }

    prepareForUpdate(): void {
        if (!this.id) {
            throw Error('id is null');
        }
        this.checkValidation();

        this.addDomainEvent(new <%= entityAngularName %>UpdatedEvent({ ...this }));
    }

<%_ if (hasStatusField) { _%>
    setStatus(status: keyof typeof <%= hasStatusField.tsType %>): void {
        if (!this.id) {
            throw Error('id is null');
        }
        this.status = status;

        this.addDomainEvent(new <%= entityAngularName %>UpdatedEvent({ id: this.id, status: this.status }));
    }

<%_ } _%>
}
